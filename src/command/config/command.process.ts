import DBConfig from "../../config/db.config";

const mapPostgresTypeToTypeScript = (postgresType: string): string => {
    switch (postgresType) {
        case 'integer':
        case 'bigint':
        case 'smallint':
        case 'numeric':
        case 'real':
        case 'double precision':
        case 'serial':
        case 'bigserial':
            return 'number';

        case 'varchar':
        case 'character varying':
        case 'text':
        case 'char':
        case 'uuid':
            return 'string';

        case 'boolean':
            return 'boolean';

        case 'date':
        case 'timestamp':
        case 'timestamptz':
        case 'time':
        case 'timetz':
            return 'Date';

        case 'json':
        case 'jsonb':
            return 'object';

        case 'bytea':
            return 'Buffer';

        default:
            return 'any'; // Pour les types non pris en charge
    }
};

export const getColumn = async (tableName: string) => {
    const pool = await DBConfig.createInstance();
    const query = `
    SELECT column_name, data_type, is_nullable, column_default
    FROM information_schema.columns
    WHERE table_name = $1;
    `;

    const pkQuery = `
    SELECT kcu.column_name
    FROM information_schema.key_column_usage AS kcu
    JOIN information_schema.table_constraints AS tc
    ON kcu.constraint_name = tc.constraint_name
    WHERE tc.table_name = $1 AND tc.constraint_type = 'PRIMARY KEY';
    `;

    const fkQuery = `
    SELECT kcu.column_name, ccu.table_name AS foreign_table, ccu.column_name AS foreign_column
    FROM information_schema.key_column_usage AS kcu
    JOIN information_schema.table_constraints AS tc
      ON kcu.constraint_name = tc.constraint_name
    JOIN information_schema.constraint_column_usage AS ccu
      ON tc.constraint_name = ccu.constraint_name
    WHERE tc.table_name = $1 AND tc.constraint_type = 'FOREIGN KEY';
    `;

    try {
        const res = await pool.query(query, [tableName]);

        const pkRes = await pool.query(pkQuery, [tableName]);
        const primaryKeys = pkRes.rows.map((row) => row.column_name);

        const fkRes = await pool.query(fkQuery, [tableName]);
        const foreignKeys = fkRes.rows.map((row) => ({
            column: row.column_name,
            foreignTable: row.foreign_table,
            foreignColumn: row.foreign_column,
        }));

        // Convertir les types PostgreSQL en types TypeScript
        const columnsWithTypeScriptTypes = res.rows.map((row) => {
            const isPrimary = primaryKeys.includes(row.column_name);
            const isAutoIncrement = row.column_default?.includes('nextval') || false;
            const foreignKey = foreignKeys.find((fk) => fk.column === row.column_name);

            return {
                name: row.column_name,
                type: mapPostgresTypeToTypeScript(row.data_type),
                nullable: row.is_nullable === 'YES',
                isPrimary,
                isAutoIncrement,
                foreignKey: foreignKey ? {
                    table: foreignKey.foreignTable,
                    column: foreignKey.foreignColumn,
                } : null,
            }
        });

        return columnsWithTypeScriptTypes;
    } catch (err) {
        console.error('Erreur lors de la récupération des colonnes :', err);
        throw err;
    }
}

export const generateTypecriptModel = async (tableName: string, fkColumns: any[] = []): Promise<string> => {
    const columns = await getColumn(tableName);

    // Filtrer les colonnes qui sont des FK et pour lesquelles on a dit "oui"
    const fkColumnsToInclude = fkColumns;


    const template = `// Generated by nodajpa
import { Column, Entity,${fkColumnsToInclude.length !== 0 ? ' ManyToOne,' : ''} Table } from "nodajpa";
${fkColumnsToInclude.map((fkColumn) => {
        return (`import { ${fkColumn.foreignTable.charAt(0).toUpperCase() + fkColumn.foreignTable.slice(1)} } from "./${fkColumn.foreignTable}.model";`);
    }).join("\n")}

@Table("${tableName}")
export class ${tableName.charAt(0).toUpperCase() + tableName.slice(1)} extends Entity {

    // Columns
    ${columns.map(column => {
        const isForeignKey = fkColumnsToInclude.some(fk => fk.column === column.name);
        if (isForeignKey) {
            const foreignTable = fkColumnsToInclude.find(fk => fk.column === column.name).foreignTable;
            return (`@ManyToOne({joinColumn : '${column.name}',entity : ${foreignTable.charAt(0).toUpperCase() + foreignTable.slice(1)}})
    ${foreignTable} : ${foreignTable.charAt(0).toUpperCase() + foreignTable.slice(1)}${column.nullable ? ' | null' : ''};
    `);
        } else {
            return (`@Column({name : '${column.name}'${column.isPrimary ? ', primary_key : true' : ''}${column.isAutoIncrement ? ', autoincrement : true' : ''}})
    ${column.name} : ${column.type}${column.nullable ? ' | null' : ''};
    `);
        }
    }).join("\n    ")}

    // Constructor
    constructor(${columns.map(column => {
        const isForeignKey = fkColumnsToInclude.some(fk => fk.column === column.name);
        if (isForeignKey) {
            const foreignTable = fkColumnsToInclude.find(fk => fk.column === column.name).foreignTable;
            return `${foreignTable}?: ${foreignTable.charAt(0).toUpperCase() + foreignTable.slice(1)}`;
        } else {
            return `${column.name}?: ${column.type}`;
        }
    }).join(", ")}) {
        super();
        ${columns.map(column => {
            const isForeignKey = fkColumnsToInclude.some(fk => fk.column === column.name);
            if (isForeignKey) {
                const foreignTable = fkColumnsToInclude.find(fk => fk.column === column.name).foreignTable;
                return `this.${foreignTable} = ${foreignTable} || null;`;
            } else {
                switch (column.type) {
                    case 'number':
                        return `this.${column.name} = ${column.name} || 0;`;
                    case 'string':
                        return `this.${column.name} = ${column.name} || '';`;
                    default:
                        return `this.${column.name} = ${column.name} || null;`;
                }
            }
    }).join("\n        ")}
    }
}
`;

    return template;
};